/**
 * Security Test: Node-forge Vulnerability Detection
 * 
 * This test ensures that node-forge is not present in the dependency tree
 * and that if it is added, only safe versions (>= 1.3.1) are used.
 */

import { describe, it, expect } from '@jest/globals';
import { execSync } from 'child_process';
import fs from 'fs';
import path from 'path';

describe('Node-forge Security Tests', () => {
  describe('Dependency Check', () => {
    it('should not have node-forge as a direct dependency', () => {
      const packageJson = JSON.parse(
        fs.readFileSync(path.join(process.cwd(), 'package.json'), 'utf-8')
      );

      const allDeps = {
        ...packageJson.dependencies,
        ...packageJson.devDependencies,
      };

      expect(allDeps).not.toHaveProperty('node-forge');
    });

    it('should not have node-forge in dependency tree', () => {
      try {
        const output = execSync('npm ls node-forge 2>&1', {
          encoding: 'utf-8',
          cwd: process.cwd(),
        });

        // If node-forge is found, the output will contain version info
        expect(output).toContain('(empty)');
      } catch (error: any) {
        // Exit code 1 means not found, which is what we want
        expect(error.status).toBe(1);
        expect(error.stdout).toContain('(empty)');
      }
    });

    it('should have overrides for node-forge in package.json', () => {
      const packageJson = JSON.parse(
        fs.readFileSync(path.join(process.cwd(), 'package.json'), 'utf-8')
      );

      expect(packageJson.overrides).toBeDefined();
      expect(packageJson.overrides['node-forge']).toBe('>=1.3.1');
    });
  });

  describe('Package Lock Verification', () => {
    it('should not contain node-forge entries in package-lock.json', () => {
      const packageLock = fs.readFileSync(
        path.join(process.cwd(), 'package-lock.json'),
        'utf-8'
      );

      // Search for node-forge entries
      const hasNodeForge = packageLock.includes('"node-forge"') || 
                          packageLock.includes('node-forge');

      expect(hasNodeForge).toBe(false);
    });
  });

  describe('Security Configuration', () => {
    it('should have .npmrc with audit enabled', () => {
      const npmrcPath = path.join(process.cwd(), '.npmrc');
      expect(fs.existsSync(npmrcPath)).toBe(true);

      const npmrcContent = fs.readFileSync(npmrcPath, 'utf-8');
      expect(npmrcContent).toContain('audit=true');
    });

    it('should have security documentation', () => {
      const securityMdPath = path.join(process.cwd(), 'SECURITY.md');
      expect(fs.existsSync(securityMdPath)).toBe(true);

      const securityContent = fs.readFileSync(securityMdPath, 'utf-8');
      expect(securityContent).toContain('node-forge');
      expect(securityContent).toContain('ASN.1');
    });

    it('should have vulnerability report document', () => {
      const reportPath = path.join(
        process.cwd(),
        'docs/security/NODE_FORGE_VULNERABILITY_REPORT.md'
      );
      expect(fs.existsSync(reportPath)).toBe(true);

      const reportContent = fs.readFileSync(reportPath, 'utf-8');
      expect(reportContent).toContain('CVE-2024-48939');
      expect(reportContent).toContain('MITIGATED');
    });
  });

  describe('NPM Audit Check', () => {
    it('should have no high or critical vulnerabilities', () => {
      try {
        const auditOutput = execSync('npm audit --json', {
          encoding: 'utf-8',
          cwd: process.cwd(),
        });

        const auditData = JSON.parse(auditOutput);
        
        expect(auditData.metadata.vulnerabilities.high).toBe(0);
        expect(auditData.metadata.vulnerabilities.critical).toBe(0);
      } catch (error: any) {
        // npm audit exits with 1 if vulnerabilities found
        // Parse the output to check severity
        if (error.stdout) {
          const auditData = JSON.parse(error.stdout);
          expect(auditData.metadata.vulnerabilities.high).toBe(0);
          expect(auditData.metadata.vulnerabilities.critical).toBe(0);
        }
      }
    });
  });

  describe('Codebase Scan', () => {
    it('should not import or require node-forge in any file', () => {
      const findNodeForgeImports = (dir: string): string[] => {
        const results: string[] = [];
        const files = fs.readdirSync(dir);

        for (const file of files) {
          const filePath = path.join(dir, file);
          const stat = fs.statSync(filePath);

          // Skip node_modules, .git, and other common directories
          if (stat.isDirectory()) {
            if (!['node_modules', '.git', '.next', 'coverage', 'dist'].includes(file)) {
              results.push(...findNodeForgeImports(filePath));
            }
          } else if (
            stat.isFile() &&
            /\.(ts|tsx|js|jsx)$/.test(file)
          ) {
            // Skip security test files and check scripts themselves
            if (filePath.includes('node-forge-vulnerability')) {
              continue;
            }
            
            const content = fs.readFileSync(filePath, 'utf-8');
            if (
              content.includes('node-forge') ||
              content.includes("from 'forge'") ||
              content.includes('require("forge")')
            ) {
              results.push(filePath);
            }
          }
        }

        return results;
      };

      const filesWithNodeForge = findNodeForgeImports(process.cwd());
      
      expect(filesWithNodeForge).toHaveLength(0);
      
      if (filesWithNodeForge.length > 0) {
        console.error('Files importing node-forge:', filesWithNodeForge);
      }
    });
  });
});
